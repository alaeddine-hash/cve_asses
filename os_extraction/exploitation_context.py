import asyncio
from decimal import Decimal
import json
from langchain_openai import ChatOpenAI

from get_cve import get_filtered_cves

import os
from datetime import datetime

from augmented_cve_gpt import extract_advisory_links, scrape_urls



def default_serializer(obj):
    """ Custom serializer to handle non-serializable objects like datetime and Decimal """
    if isinstance(obj, datetime):
        return obj.isoformat()  # Convert datetime to ISO format
    elif isinstance(obj, Decimal):
        return float(obj)  # Convert Decimal to float for JSON serialization
    raise TypeError(f"Object of type {obj.__class__.__name__} is not JSON serializable")




def create_prompt_for_exploitation_context(cve):
    prompt = f"""
You are a cybersecurity analyst with expertise in vulnerability assessment and exploitation analysis. Your task is to analyze the following CVE and provide detailed information about the exploitation context of the vulnerable component.

**CVE Details:**

- **CVE ID:** {cve['cve_id']}
- **Description:** {cve['description']}
- **CVSS Vector V3:** {cve.get('cvss_vector_v3')}
**Advisory Contents:**
"""
    # Include advisory contents if available
    for advisory in cve.get('advisory_contents', []):
        prompt += f"\n- **URL:** {advisory['url']}\n**Content:**\n{advisory['content']}\n"

    prompt += """

**Instructions:**

1. **Analyze the CVE description and any available information to identify the specific contexts or conditions under which the vulnerable component can be exploited.**

2. **Determine if the exploitation is valid only in certain environments or configurations. For example:**
   - **Is the vulnerability exploitable only when the component is used on the server side or client side?**
   - **Does the exploitation require specific operating systems, versions, or configurations?**
   - **Are there any dependencies or additional components required for exploitation?**

3. **Provide detailed information about these contexts or conditions, explaining why the exploitation is limited to them.**

**Output Format:**

Provide your response in valid JSON format as follows (do not include any code block delimiters or language specifiers):

{{
  "cve_id": "{cve['cve_id']}",
  "exploitation_context": {{
    "contexts": [
      {{
        "environment": "Description of the environment (e.g., server-side, specific OS, configuration)",
        "explanation": "Detailed explanation of why exploitation is valid only in this context"
      }}
      // Include additional contexts if applicable
    ],
    "general_explanation": "Overall explanation of the exploitation context"
  }},
  "Side": "you will extract here if it client/server or library"
}}

**Important Guidelines:**

- **Focus solely on the exploitation context of the vulnerable component.**
- **Do not include any explanations or text outside the JSON object.**
- **Provide only the JSON object.**
- **Ensure the JSON is properly formatted and parsable.**
"""
    return prompt


def process_cve_exploitation_context(cve):
    print(f"Processing CVE ID: {cve['cve_id']}")
    # Extract advisory links
    references = extract_advisory_links(cve)
    # Scrape the advisory contents
    try:
        cve['advisory_contents'] = asyncio.run(scrape_urls(references))
    except Exception as e:
        print(f"Error during advisory scraping: {e}")
        cve['advisory_contents'] = []
    # Create the prompt
    prompt = create_prompt_for_exploitation_context(cve)

    # Call the LLM
    try:
        # Initialize the LLM
        llm = ChatOpenAI(
            model_name='gpt-4o-mini',
            temperature=0.0,
        )

        # Get the response from the LLM
        response = llm.invoke(prompt)
        output_text = response.content.strip()

        # Clean the output_text by removing code block delimiters and language specifiers
        output_text = output_text.strip()
        if output_text.startswith('```'):
            output_text = output_text.strip('`')
            # Remove the language specifier if present
            if output_text.startswith('json'):
                output_text = output_text[4:].strip()

        # Parse the JSON output
        try:
            result = json.loads(output_text)
            # Update the CVE with new attributes
            cve['exploitation_context'] = result.get('exploitation_context')
            cve['Side'] = result.get('Side')
            print(f"Exploitation Context for CVE ID {cve['cve_id']}:")
            print(json.dumps(result['exploitation_context'], indent=2))
        except json.JSONDecodeError as e:
            print(f"Error parsing JSON response for CVE ID {cve['cve_id']}: {e}")
            print("LLM Output:")
            print(output_text)
            return None  # Skip further processing if parsing fails
        cve['advisory_contents'] = ' '
        return cve  # Return the augmented CVE

    except Exception as e:
        print(f"Error during LLM processing for CVE ID {cve['cve_id']}: {e}")
        return None


def main():
    cves_with_context = []
    cves = get_filtered_cves(2024, 2024, 90)  # Adjust the parameters as needed
    n = 70  # Number of CVEs to skip
    cves = cves[n:]  # Remove the first n CVEs


    for cve in cves:
        augmented_cve = process_cve_exploitation_context(cve)
        if augmented_cve:
            cves_with_context.append(augmented_cve)

    # Optionally, save the augmented CVEs to a file or database
    with open('cves_with_exploitation_context_2.json', 'w') as f:
        json.dump(cves_with_context, f, indent=2, default=default_serializer)

    print("Completed processing CVEs for exploitation context.")



